use std::{collections::HashMap, sync::Arc};

use anyhow::Result;
use axum::{
    extract::Path,
    extract::{ws::Message, State},
    http::header::CONTENT_TYPE,
    response::{Html, IntoResponse},
    routing::get,
    Router,
};
use tera::Tera;
use tokio::sync::RwLock;

use crate::project::Project;

/// Stores the rendered basic HTML content, for serving previews or writing to files.
pub struct DefaultHtmlContent {
    /// `index.html` contents
    pub index: String,
    /// Contents of `projects/` indexed by name
    pub projects: HashMap<String, String>,
    /// CSS generated by railwind for all rendered content
    pub css: String,
    /// Templating engine
    pub tera: Tera,
    /// List of websockets to send to when content changes
    pub websockets: Vec<tokio::sync::mpsc::Sender<axum::extract::ws::Message>>,
}

impl DefaultHtmlContent {
    // Creates an empty `DefaultHtmlContent` object, which must be `render`ed before use.
    pub fn new() -> Self {
        Self {
            index: String::new(),
            projects: HashMap::new(),
            css: String::new(),
            tera: Tera::default(),
            websockets: Vec::new(),
        }
    }

    // Render the basic HTML from the given content.
    pub async fn render(&mut self, content: &Vec<Project>) -> Result<()> {
        // Load template engine
        self.tera = Tera::new("defaulthtml-templates/**/*.tera")?;

        // Make index page
        let mut context = tera::Context::new();
        context.insert("projects", &content);
        self.index = self.tera.render("index.tera", &context)?;

        // Make project pages
        self.projects = HashMap::new();
        for project in content {
            let mut context = tera::Context::new();
            context.insert("project", &project);
            self.projects.insert(
                project.url.clone(),
                self.tera.render("project.tera", &context)?,
            );
        }

        // Make CSS
        self.make_css();

        // Notify websockets and remove them, as they should reconnect with a new socket
        println!(
            "Notifying {} websockets of live-reload.",
            self.websockets.len()
        );
        for ws in self.websockets.drain(..) {
            ws.send(Message::Binary(vec![0])).await?;
        }
        Ok(())
    }

    /// Makes the css string from the current rendered content.
    pub fn make_css(&mut self) {
        use railwind::*;
        // Concatenate all html files together for railwind to parse.
        let mut html = self.index.clone();
        for (_, project) in self.projects.iter() {
            html.push_str(project);
        }
        // Parse html string (just an regex match internally, so concatenated html is fine)
        self.css = parse_to_string(
            Source::String(html, CollectionOptions::Html),
            true,
            &mut vec![],
        );
    }

    // Writes the basic HTML to the `defaulthtml/` directory.
    pub fn write(&self) -> Result<(), String> {
        // Write index
        std::fs::write("defaulthtml/index.html", &self.index)
            .map_err(|e| format!("Failed to write index.html file: {}", e))?;

        // Write projects
        for (url, html) in self.projects.iter() {
            std::fs::write(format!("defaulthtml/projects/{}.html", url), html)
                .map_err(|e| format!("Failed to write {}.html file: {}", url, e))?;
        }

        // Write CSS
        std::fs::write("defaulthtml/css.css", &self.css)
            .map_err(|e| format!("Failed to write css.css file: {}", e))?;
        Ok(())
    }

    // Returns an axum router for serving basic HTML, which takes the `DefaultHtmlContent` as state.
    pub fn axum_router() -> Router<Arc<RwLock<Self>>> {
        Router::new()
            .route(
                "/",
                get(|State(content): State<Arc<RwLock<Self>>>| async move {
                    let content = content.read().await;
                    Html(Self::live_reload(content.index.clone()))
                }),
            )
            .route("/projects/*path", get(|Path(path): Path<String>, State(content): State<Arc<RwLock<Self>>>| async move {
                let content = content.read().await;
                content.projects.get(&path).map(|s| Html(Self::live_reload(s.clone()))).ok_or(format!("Bad Path: {} ({:?})", path, content.projects.keys()))
            }))
            .route("/css.css", get(|State(content): State<Arc<RwLock<Self>>>| async move {
                let content = content.read().await;
                ([(CONTENT_TYPE, "text/css")], content.css.clone())
            }))
            .route("/ws", get(Self::ws_handler))
    }
    /// Wraps the given HTML in a live-reload script using websockets.
    fn live_reload(html: String) -> String {
        format!(
            r#"{html}
            <script>
                var socket = new WebSocket("ws://localhost:3000/defaulthtml/ws");
                socket.onmessage = function (event) {{
                    location.reload();
                }};
            </script>
            "#
        )
    }
    /// Handles websocket connections, adding them to a queue to update when content changes.
    async fn ws_handler(
        ws: axum::extract::ws::WebSocketUpgrade,
        State(content): State<Arc<RwLock<Self>>>,
    ) -> impl IntoResponse {
        ws.on_upgrade(|mut socket| async move {
            // Create a channel for sending messages to the websocket.
            let (tx, mut rx) = tokio::sync::mpsc::channel(1);
            // Add the channel to the list of websockets to send to when content changes.
            // After one live-reload message is sent, it will be removed, as the client should reconnect with a new socket.
            let mut content = content.write().await;
            content.websockets.push(tx);
            println!("Socket connected, listening for live-reloads.");
            tokio::spawn(async move {
                if let Some(msg) = rx.recv().await {
                    socket.send(msg).await.unwrap_or_else(|e| {
                        println!("Failed to send live-reload to socket: {e}");
                    });
                }
            });
        })
    }
}
