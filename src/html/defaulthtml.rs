use std::{collections::HashMap, sync::Arc};

use color_eyre::Result;
use tera::Tera;

use crate::blogpost::{BlogPostContent, RenderCallback};

/// Stores the rendered basic HTML content, for serving previews or writing to files.
#[derive(Default)]
pub struct Content {
    /// `index.html` contents
    pub index: String,
    /// `themes.html` contents
    pub themes: String,
    /// Contents of `projects/` indexed by name
    pub projects: HashMap<String, String>,
    /// Contents of `blog/` indexed by name
    pub blog: HashMap<String, String>,
    /// CSS generated by railwind for all rendered content
    pub css: String,
    /// Templating engine
    pub tera: Tera,
}

impl Content {
    /// Renders the default HTML pages from the general content.
    pub async fn new(content: &crate::Content) -> Result<Self> {
        // The template engine is the only thing that must be loaded for html-specific content, so load that first.
        let mut tera = Tera::new("html-content/default/**/*.tera")?;
        tera.autoescape_on(vec![".tera"]);

        // To render the content, we just create an empty struct and call the refresh function with the content.
        let mut result = Self {
            tera,
            ..Default::default()
        };
        result.refresh(content).await?;
        Ok(result)
    }

    /// Rerender the basic HTML from the given content.
    pub async fn refresh(&mut self, content: &crate::Content) -> Result<()> {
        // Make index page
        let context = tera::Context::from_serialize(content)?;
        self.index = self.tera.render("index.tera", &context)?;

        // Make themes page
        self.themes = self.tera.render(
            "themes.tera",
            &tera::Context::from_serialize(&content.themes_info)?,
        )?;

        // Make project pages
        self.projects = HashMap::new();
        for project in content.projects.iter() {
            let mut context = tera::Context::new();
            context.insert("project", &project);
            self.projects.insert(
                project.url.clone(),
                self.tera.render("project.tera", &context)?,
            );
        }

        // Make blog pages
        self.blog = HashMap::new();
        for blog_post in content.blog_posts.iter() {
            let mut context = tera::Context::new();
            context.insert("post", &blog_post);
            context.insert("content_html", &render_blog_post(&blog_post.content)?);
            self.blog.insert(
                blog_post.url.clone(),
                self.tera.render("blogpost.tera", &context)?,
            );
        }

        // Make CSS
        self.make_css();

        Ok(())
    }

    /// Makes the css string from the current rendered content.
    pub fn make_css(&mut self) {
        use railwind::*;
        // Concatenate all html files together for railwind to parse.
        let mut html = self.index.clone();
        html.push_str(&self.themes);
        for (_, project) in self.projects.iter() {
            html.push_str(project);
        }
        for (_, blog_post) in self.blog.iter() {
            html.push_str(blog_post);
        }
        // Parse html string (just an regex match internally, so concatenated html is fine)
        self.css = parse_to_string(
            Source::String(html, CollectionOptions::Html),
            true,
            &mut vec![],
        );

        // Hijack dark mode to use the "class" strategy
        while let Some(i) = self.css.find("@media (prefers-color-scheme: dark) {") {
            // Replace media selector with class selector
            let line_end = self.css[i..]
                .find('\n')
                .expect("No newline after dark mode selector");
            self.css
                .replace_range(i..i + line_end, "@media screen { .dark");
        }
    }

    /// Get a page.
    pub fn get_page(&self, page: super::Page) -> Option<String> {
        use super::Page::*;
        match page {
            Index => Some(self.index.clone()),
            Themes => Some(self.themes.clone()),
            Project(name) => self.projects.get(&name).cloned(),
            BlogPost(name) => self.blog.get(&name).cloned(),
        }
    }

    /// Serve the css.
    pub fn router() -> axum::Router<Arc<super::HtmlServer>> {
        use axum::{extract::State, routing::get, Router};
        use hyper::header::CONTENT_TYPE;
        Router::new().route(
            "/css.css",
            get(|State(content): State<Arc<super::HtmlServer>>| async move {
                (
                    [(CONTENT_TYPE, "text/css")],
                    content.content.read().await.default.css.clone(),
                )
            }),
        )
    }
}

/// Render a blog post content to HTML.
fn render_blog_post(content: &BlogPostContent) -> Result<String> {
    // Render links as html for testing callback
    let link_callback = RenderCallback::Link(&|link, contents| {
        format!("<a href=\"{}\">{}</a>", link.url, contents)
    });
    // Render
    content.render_markdown(&[link_callback])
}
