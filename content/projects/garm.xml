<?xml version="1.0" encoding="UTF-8"?>
<project>
<name>Garmin Testing Device</name>
<url>garmin</url>
<description>Underwater testing device for Garmin dive watches and air tank sensors, controlled automatically using a web app.</description>
<date>2022.12-2023.05</date>
<skills>
    <skill>Embedded Development (ESP-IDF)</skill>
    <skill>Frontend Web Development</skill>
    <skill>PCB Design</skill>
    <skill>Mechatronics</skill>
    <skill>Control Systems</skill>
</skills>
<content>
    <section>
        <title>Overview</title>
        <g>
            <p>Garmin's Sonar Engineering Team creates several dive watches and air tank sensors designed to communicate with each other using their SubWave Sonar technology while underwater. Until recently, to test and calibrate these precise devices, Garmin attached them to a boat using 12 ft PVC poles, leading to several feet of deflection during testing and decreasing both accuracy and repeatability of results.</p>
            <p>To make the testing and calibration process more stable, accurate, and consistent, I worked with a team of engineers in my EGR 102 class to design and build a new mounting system that would hold the dive watches and air tank sensors fixed in position underwater, while being controllable using a web app to set the exact depth and angular position of the devices being tested.</p>
            <p>As electrical team lead, I personally designed the mechatronic control system, from the motors used to physically move the testing rig to the UX of the web app used by engineers while performing tests, as well as all the microcontrollers and firmware in between.</p>
        </g>
        <img src="garm_installed.jpeg" alt="A long pole-shaped device, made of aluminum and fiberglass rebar, mounted to the side of a boat.">
            <caption>The new testing system installed on the boat.</caption>
        </img>
    </section>
    <criteria>
        <title>Design Goals</title>
        <item>
            <title>Accuracy</title>
            <description>Control system must move devices to within 2" of the desired depth and 5° of the desired angle, withstanding forces from the weight of the device and underwater currents</description>
        </item>
        <item>
            <title>Durability</title>
            <description>The testing system will be stored outdoors on a boat and be operated underwater, but still must be built to last without significant maintainance.</description>
        </item>
        <item>
            <title>Usability</title>
            <description>Several test engineers will work with the system, so it should be fairly easy to use and understand, working with the engineers' goals and workflow rather than against them. In addition to human usability, it should also be easy to extend and integrate with current or future autonomous testing workflows.</description>
        </item>
    </criteria>
    <section>
        <title>Getting Physical</title>
        <g>
            <p>While I <a href="https://www.grantweerts.com/garmin">can't take credit</a> for the mechanical design or manufacturing of the testing rig's structure, making it move required designing the best possible depth and rotation control system, as well as selecting motors that had the necessary power and precision.</p>
            <p>For the depth adjustment, we used a winch-like system with a motorized spool lifting the tested device up and down on a telescoping pole, while rotation was achieved by rotating the entire testing rig using a motorized belt. This was done to avoid placing any electronics underwater while maintaining full control over the device's position.</p>
            <p>For motors, we eventually chose small, high-gear-ratio DC motors <a href="https://www.dfrobot.com/product-633.html">(this one, in particular)</a> with quadrature encoders to provide the necessary torque while remaining power-efficient, small, and inexpensive.</p>
        </g>
        <img src="garm_depthmotor.jpg" alt="A small motor driving an alumninum spool with coated steel wire wrapped around it. The motor and spool are mounted to a mounting plate, and the wire continues downward through the testing device.">
            <caption>The depth control mechanism, including the winch system used to adjust depth and the DC motor with encoder powering it.</caption>
        </img>
    </section>
    <section>
        <title>Wired Control</title>
        <g>
            <p>Because we selected simple DC motors with encoders, achieving the precise position needed required implementing some sort of control system. While the ESP-IDF framework provides a <a href="https://github.com/espressif/idf-extra-components/tree/master/pid_ctrl">PID component,</a> I implemented mine manually on top of the ESP-IDF PWM and pulse-count functionality, which was fairly simple to do.</p>
            <p>This ended up being very beneficial as we began testing with the entire assembly, as I ended up needing to add a decent amount of custom control logic beyond the basic assembly.This included functionality to recognize when the motor was stalling (somewhat common in early rotation testing), recognize when friction (and gearing) was sufficient to hold the spool in place without applying power, and move to specific angles efficiently by accounting for full rotations.</p>
        </g>
    </section>
    <section>
        <title>Wireless Control</title>
        <g>
            <p>The ideal testing workflow we were focused on providing involved controlling all testing via a laptop in an intuitive, hassle-free way. We achieved this with a fairly basic web app, served by the ESP32 that also controlled the motors themselves.</p>
            <p>The primary testing rig's controller acted as an access point, providing a WiFi network that a laptop could connect to. It then served both the web app (created using <a href="https://picocss.com/">PicoCSS,</a> which I highly recommend) as well as a fairly basic API allowing for the depth and angle to be set, as well as the current position to be read. This makes the system very extensible, with any new systems able to integrate easily into the current API.</p>
            <p>Because both testing rigs needed to be controlled simultaneously, the secondary one acted in station mode, connecting to the predefined WiFi network created by the primary AP rig. The station mode rig polled the primary rig periodically for updated depth position targets, matching its own position upon observing any changes.</p>
        </g>
    </section>
    <section>
        <title>Approaching Absolute Zero (Calibration)</title>
        <g>
            <p>Given the amount of effort put into the system's precision, accuracy was obviously a large concern. For depth accuracy, a simple startup calibration routine was sufficient, raising the rig to its known minimum depth as detected by the end of the motor's travel.</p>
            <p>Rotation accuracy was a bigger concern, especially because verifying the device's current rotation underwater was difficult. To solve this, we used a Hall Effect Sensor placed at the top of the testing rig, detecting a magnet on the rotation mechanism. At startup, at least 5 rotations are completed to define an absolute zero point, and this point is monitored as the user rotates the device.</p>
            <p>During testing, both calibration systems exceeded requirements, with depth calibration varying less than 0.5" and rotation by less than 2°.</p>
        </g>
    </section>
    <!--
    TODO:
    - PID Loop
    - Hardware? (ESP, H-Bridge, PCB) Probably included elsewhere, but could be good to add H-Bridge discussion
    - ESP32 Web Server, API
    - Web App (PicoCSS)
    - "Approaching Absolute Zero (Calibration)"
    - PCB Design
    -->
</content>
<thumbnail>garm_boat.jpg</thumbnail>
<priority>20</priority>
</project>